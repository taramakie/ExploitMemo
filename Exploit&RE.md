# Exploit&Reversing
[Nightmare](https://github.com/guyinatuxedo/nightmare)を解きながらExploitに役立ちそうなことを自分用にメモ。
## コマンド
### file
ビット数、エンディアン、アーキテクチャ、ライブラリのリンクは動的か静的か、シンボルの有無を確認する。
### pwn checksec
アーキテクチャやRELRO、Stack Canary、NX、PIEといったエクスプロイトへの緩和策の有無を確認できる。
### ROPgadget
[ROPのガジェットを列挙できるPythonツール](https://github.com/JonathanSalwan/ROPgadget)。「`ROPgadget --binary [バイナリ]`」で列挙できる。
### one_gadget
一発で`execve("/bin/sh")`を呼び出すガジェットを見つけてくる。[詳細](https://github.com/david942j/one_gadget)。内部の動作としてはシンボリック実行でワンガジェットを見つけている。

## Python
### 生のバイナリをプリントする
sys.stdout.bufferのwriteを使うとPython 3系で生のバイナリをプリントできる。
```
import sys; sys.stdout.buffer.write(b"\xde\xad\xbe\xef")
```
### 数値をバイトに変換する
`to_bytes`メソッドを使う。第一引数にバイトのサイズ、第二引数にエンディアンを指定する。
### 数値の文字形式への変換でゼロ埋めを行う
`format`を使う。第一引数に変換したい数値、第二引数にフォーマットの形式を指定する。数値をアスキーコードなどに変換する場合decodeメソッドを使う。

## 危険な関数
### gets
NewLineやEOFが入力されるまで入力値を受け取るため、bofの可能性がある関数。メモリへの読み込み時に改行文字はNULL文字になる。
### scanf
フォーマットストリングで入力される文字数を制限しないとオーバーフローする可能性がある。
### memcpy
第三引数に指定できる値によってはbofの可能性がある。

## エラーとその回避策
### System関数のアラインメントのエラー
system関数内の以下のようなところでSIGSEGVエラーが出る時がある。原因はアラインメントの問題で16バイトにそろえてやる必要がある。
```
0x7fbc2ff54e3c <do_system+364>  movaps XMMWORD PTR [rsp+0x50], xmm0
```
なんとかスタックのバイトを8バイトずらす必要がある。最初からやっているとNightmareでは[Warmup](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)でこの問題にぶつかるはず。ジャンプ先のアドレスを0x40060eにして「`push rbp`」を飛ばすことで回避した。[このブログ記事](https://smallkirby.hatenablog.com/entry/2019/08/23/223507)のように、retに飛ぶROPを目的とするジャンプ先の前に入れても解決できるはず。

## セキュリティ機構とその回避
### ASLR&PIE
#### ASLR
スタックやヒープ、libcなどの領域がある程度ランダムになる。コード領域はそのまま。オフセットは変化しないので、メモリの一部をリークさせれば、それから計算してバイパス可能。具体的な方法は後述。
#### PIE
PIE(Position Independent Executable)はコード領域がランダム化できるようにcall命令やjmp命令が絶対アドレスではなく、相対アドレスで指定される。PIEでは通常の方法でブレークポイントをセットできないが、gefでは「`pie b *[アドレス]`」でブレークポイントをセットし、「`pie run`」で実行することでブレークポイントが有効な状態で実行することができる。回避方法は基本的にASLRと同じ。
### NXビット/DEP
スタックやヒープなどのデータを格納する領域でのデータ実行を無効にする。ROPやret2libcでバイパスできる。
### Stack canary
回避方法はcanaryの漏えいかブルートフォース。ブルートフォースの場合、親プロセスと子プロセスでcanaryが変化しない性質を利用するパターンがある。Linuxの場合、最下位バイトは0x00になる(gccではそうだが、コンパイラやバージョンによるかも)。Visual Studioでは0x00にならない。またVisual Studioの場合、spとXORを取る。
### Relro(Read Only Relocation)
NXと同様メモリの権限を設定する。具体的にはGOTテーブルをリードオンリーにすることでGOTオーバーライトのような攻撃を防御可能にする。GOTテーブルはlazy bindingを行うために利用されるメモリ領域で関数のアドレスを保持する。

## その他参考資料
- [シェルコードまとめ](http://shell-storm.org/shellcode/index.html)
- [x64システムコールのレジスタの設定値](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)
- [x86システムコールのレジスタ設定値](https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux)
- [Ghidraの設定](https://securelist.com/how-to-train-your-ghidra/108272/)